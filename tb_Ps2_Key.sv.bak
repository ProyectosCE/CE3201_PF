`timescale 1ns/1ps
module tb_Ps2_Key;

  //--------------------------------------------------------------------
  //  Señales
  //--------------------------------------------------------------------
  logic clk;
  logic ps2_clk;
  logic ps2_data;
  logic [7:0] key_code;
  logic [3:0] quadrant;   // No se usa, pero la interfaz lo requiere

  //--------------------------------------------------------------------
  //  Instancia del DUT
  //--------------------------------------------------------------------
  Ps2_Key dut (
    .clk      (clk),
    .ps2_clk  (ps2_clk),
    .ps2_data (ps2_data),
    .key_code (key_code),
    .quadrant (quadrant)
  );

  //--------------------------------------------------------------------
  //  Reloj del sistema: 100 MHz (10 ns)
  //--------------------------------------------------------------------
  initial begin
    clk = 0;
    forever #5 clk = ~clk;
  end

  //--------------------------------------------------------------------
  //  Líneas PS/2: estado inactivo
  //--------------------------------------------------------------------
  initial begin
    ps2_clk  = 1;
    ps2_data = 1;
  end

  //--------------------------------------------------------------------
  //  Parámetros de prueba
  //--------------------------------------------------------------------
  localparam byte TEST_CODE = 8'h6B; // ←  flecha izquierda
  localparam time T_HALF    = 25_000; // 25 µs  (bit period/2)
  localparam time T_IDLE    = 100_000; // 100 µs entre reset y envío

  //--------------------------------------------------------------------
  //  Tarea: envía un byte PS/2 (11 bits: start, data[7:0] LSB‑first,
  //         parity impar, stop)
  //--------------------------------------------------------------------
  task automatic send_byte (input byte data);
    bit parity;
    bit [10:0] frame;     // {stop, parity, data, start}
    integer i;

    // Paridad impar: si ^data es 1 → poner parity=0, y viceversa
    parity = ~(^data);

    frame = {1'b1, parity, data, 1'b0};

    for (i = 0; i < 11; i++) begin
      // Preparar dato antes del flanco descendente
      ps2_data = frame[i];

      // Generar flanco descendente
      #(T_HALF);
      ps2_clk = 0;

      // Mantener low
      #(T_HALF);

      // Generar flanco ascendente
      ps2_clk = 1;

      // Tiempo de guardia antes del siguiente bit
      #(T_HALF);
    end

    // Dejar línea en reposo
    ps2_data = 1;
  endtask

  //--------------------------------------------------------------------
  //  Estímulo + auto‑verificación
  //--------------------------------------------------------------------
  initial begin
    bit pass = 0;

    // Pequeño retardo inicial
    #(T_IDLE);

    // Enviar la tecla de prueba
    send_byte(TEST_CODE);

    // Esperar hasta 5 ms a que aparezca el código correcto
    repeat (500_000) @(posedge clk) begin
      if (key_code == TEST_CODE) begin
        $display("[%0t ns] KEY RECEIVED: 0x%h – TEST PASSED", $time, key_code);
        pass = 1;
        $finish;
      end
    end

    // Si llegamos aquí, falló
    if (!pass) begin
      $display("[%0t ns] ERROR: key_code nunca fue 0x%h – TEST FAILED", $time, TEST_CODE);
      $finish;
    end
  end

endmodule
